# 第二课 所有权



### 1.Rust所有权

#### 存在原因（为了内存安全）

- ​	跟踪代码的哪些部分正在使用heap的哪些数据

- ​	最小化heap（堆）上的重复数据

- ​	清理heap上未使用的数据以免空间不足

#### 概念

- ​	一句话解释：谁（获得着）控制这个数据的生死的权利。

- ​	在Rust里，每一个值都有一个决定其生命周期的唯一的所有者(owner)。

#### 定义

​	Rust中的所有权笼统讲就是一套管理内存的方案，根据这套内存管理方案使得Rust无须内存垃圾回收机制就可以保障内存安全和运行效率

#### 1.1三个规则

- Rust中，每一个值（资源）都有一个所有者；

- 任何一个时刻，一个值只有一个所有者；

- 当所有者所在作用域结束的时候，值会被释放掉

  

#### 1.2.两个概念--所有者和作用域

- 所谓所有者，在代码中，就表示为变量。也就是说所有者会用变量名来表示
- 变量的作用域，就是变量有效（valid）的那个区间。在Rust中，简单来说就是在一对花括号括起的里面部分中，从变量创建时开始，到花括号结束的地方



#### 1.3.RAII (Resource Acquisition Is Initialization) 

​	这种堆内存资源随着关联的栈上局部变量一起被回收的内存管理特性，叫作 RAII



### 2.关于引用

#### 2.1.不可变引用(&T) 

​	所有者可以读取引用指向的数据，但不能修改数据

#### 2.2.可变引用(&mut T)

​	所有者可以读取引用指向的数据，并能够修改指向的数据

#### 2.3.规则

- 引用作用域从它定义到它最后一次使用时结束！如果它定义了，但并没有被使用，那它的作用域就只有它定义的那一行，即，出生即死亡


- 一个资源的可变引用与不可变引用的作用域不能交叠（overlap）！也可以说不能同时存在
- 引用（不可变引用和可变引用都是）变量的作用域不会长于所有权变量的作用域。肯定的，不然就会出现悬锤引用了，这是典型的内存安全问题。Rust中的
  引用必定是有效的
- 某个时刻对某个资源只能存在一个可变引用，不能有超过一个可变引用同时存在；
- 一个资源的不可变引用，可以同时存在多个
- 不可变引用可以被复制
- 可变引用不能被复制，只能被move



```rust
fn main() {
	let mut a = 10u32;	//一个拥有所有权的变量作用域是从它的定义时到花括号结束
	let b = &mut a;		//引用的作用域是从它的定义到最后一次使用时结束
	*b = 20;			//如果它被定义了，但没被使用，那么它的作用域就只有它定义的那一行，即出生就死亡
	println!("{b}");
	println!("{a}");
}
```



### 3.变量和数据的交互方式

- 移动 Move（浅拷贝+令拷贝前的栈数据失效）
- 克隆Clone（针对堆上面的数据）
- 复制Copy（针对栈上面的数据）

### 其他资料

- [Rust在线编译器](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021)
- [Rust标准库文档](https://doc.rust-lang.org/std/index.html)
- [rust编译套件和中文手册](https://kaisery.github.io/trpl-zh-cn/ch01-01-installation.html)
- [知乎教程](https://zhuanlan.zhihu.com/p/410291415)