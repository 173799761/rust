# 第三课 复合类型

### 1.结构体

##### 元组结构体

- 元组结构体有类型名，但是无字段名，也即字段是匿名的。

- 元组部分其实是一样的， 但是类型名不同，它们就是不同的类型。

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);
```

##### 单元结构体

​	单元结构体就是只有一个类型名字，没有任何字段的结构体。

```rust
struct ArticleModule;

fn main() {
	let module = ArticleModule;
}
```

##### 方法

```rust
impl Rectangle {
	fn area1(self: Self, n: u32) -> u32 {
		self.width * self.height * n
	}
    
	fn area2(self: &Self, n: u32) -> u32 {
		self.width * self.height * n
	}
    
	fn area3(self: &mut Self, n: u32) -> u32 {
		self.width * self.height * n
	}

}
```

​	分别对应把实例所有权传进去，传实例的不可变引用进去，传实例的可变引用进去， 三种情况。

##### 关联函数

```rust
impl Rectangle {
	fn numbers(rows: u32, cols: u32) -> u32 {
		rows * cols
	}
}
```

调用的时候，用路径符来调用：

```rust
Rectangle::numbers(10, 10);
```

##### 构造函数

```rust
Foo::new();
Foo::from();
Default
```

##### Newtype模式

```rust
struct MyVec(Vec<u8>)
```

### 2.enum

​	枚举这种类型容纳选项的可能性，每一种可能的选项都是一个变体。

##### Rust中2个常用枚举--Option和Result

```rust
Option： pub enum Optionn <T> {
	None,
	Some(T),
}
```

```rust
Result： pub enum Resultt <T, E> {
	Ok(T),
	Err(E),
}
```



##### 类C枚举

```rust
enum Number {
    Zero,
    One,
    Two,
}

// enum with explicit discriminator
enum Color {
    Red = 0xff0000,
    Green = 0x00ff00,
    Blue = 0x0000ff,
}

fn main() {
    // `enums` can be cast as integers.
    println!("zero is {}", Number::Zero as i32);
    println!("one is {}", Number::One as i32);

    println!("roses are #{:06x}", Color::Red as i32);
    println!("violets are #{:06x}", Color::Blue as i32);
}
```

输出

```bash
zero is 0
one is 1
roses are #ff0000
violets are #0000ff
```

##### 空枚举

```rust
enum MyEnum {};
```

与空结构体一样，都表示一个类型。不能被实例化



##### Impl enum

```rust
enum VeryVerboseEnumOfThingsToDoWithNumbers {
    Add,
    Subtract,
}

impl VeryVerboseEnumOfThingsToDoWithNumbers {
    fn run(&self, x: i32, y: i32) -> i32 {
        match self {
            Self::Add => x + y,
            Self::Subtract => x - y,
        }
    }
}

fn main() {
    let add = VeryVerboseEnumOfThingsToDoWithNumbers::Add;
    let a = add.run(100, 200);
    println!("{}",a)
}
```

输出

```bash
300
```

##### 模式匹配

​	初看有点类似于C/C++/Java 的 switch .. case 。但实际很不一样。

###### 使用match来做分支流程

```rust
fn main() {
    let number = 13;
    // TODO ^ Try different values for `number`

    println!("Tell me about {}", number);
    match number {
        // Match a single value
        1 => println!("One!"),
        // Match several values
        2 | 3 | 5 | 7 | 11 => println!("This is a prime"),
        // TODO ^ Try adding 13 to the list of prime values
        // Match an inclusive range
        13..=19 => println!("A teen"),
        // Handle the rest of cases
        _ => println!("Ain't special"),
        // TODO ^ Try commenting out this catch-all arm
    }

    let boolean = true;
    // Match is an expression too
    let binary = match boolean {
        // The arms of a match must cover all the possible values
        false => 0,
        true => 1,
        // TODO ^ Try commenting out one of these arms
    };

    println!("{} -> {}", boolean, binary);
}
```



输出

```bash
Tell me about 13
A teen
true -> 1
```

###### Match结合枚举

```rust
#[derive(Debug)] 
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}

fn main() {
    let a = UsState::Alabama;
    let b = Coin::Quarter(a);
    let r = value_in_cents(b);
    
    println!("{}", r);
    
}
```

输出

```bash
State quarter from Alabama!
25
```

##### if let 简化

简化前

```rust
let mut count = 0;
match coin {
	Coin::Quarter(state) => println!("State quarter from {:?}!", state),
	_ => count += 1,
}
```



简化后

```rust
let mut count = 0;

if let Coin::Quarter(state) = coin {
	println!("State quarter from {:?}!", state);
} else {
	count += 1;
}

```

##### while let

```rust
fn main() {
    // Make `optional` of type `Option<i32>`
    let mut optional = Some(0);

    // This reads: "while `let` destructures `optional` into
    // `Some(i)`, evaluate the block (`{}`). Else `break`.
    while let Some(i) = optional {
        if i > 9 {
            println!("Greater than 9, quit!");
            optional = None;
        } else {
            println!("`i` is `{:?}`. Try again.", i);
            optional = Some(i + 1);
        }
        // ^ Less rightward drift and doesn't require
        // explicitly handling the failing case.
    }
    // ^ `if let` had additional optional `else`/`else if`
    // clauses. `while let` does not have these.
}
```



输出

```bash
`i` is `0`. Try again.
`i` is `1`. Try again.
`i` is `2`. Try again.
`i` is `3`. Try again.
`i` is `4`. Try again.
`i` is `5`. Try again.
`i` is `6`. Try again.
`i` is `7`. Try again.
`i` is `8`. Try again.
`i` is `9`. Try again.
Greater than 9, quit!
```

##### 匹配元组

###### 常规匹配

```rust
fn main() {
    let a = (1,2,'a');
    
    let (b,c,d) = a;
    
    println!("{:?}", a);
    println!("{}", b);
    println!("{}", c);
    println!("{}", d);
}
```

输出

```bash
(1, 2, 'a')
1
2
a
```

###### 元组体析构--从函数的多返回值中取出数据

```rust
fn foo() -> (u32, u32, char) {
    (1,2,'a')
}

fn main() {
    let (b,c,d) = foo();
    
    println!("{}", b);
    println!("{}", c);
    println!("{}", d);
}
```

输出

```bash
1
2
a
```

##### 匹配结构体

```rust
#[derive(Debug)] 
struct User {
    name: String,
    age: u32,
    student: bool
}


fn main() {
    let a = User {
        name: String::from("mike"),
        age: 20,
        student: false,
    };
    println!("{:?}", a);
    let User {
        name,
        age,
        student,
    } = a;
    
    println!("{}", name);
    println!("{}", age);
    println!("{}", student);

}
```



输出

```bash
User { name: "mike", age: 20, student: false }
mike
20
false
```

##### 函数中的模式匹配

###### 例子1 形参元组

```rust
fn foo((a, b, c): (u32, u32, char)) {
    println!("{}", a);
    println!("{}", b);
    println!("{}", c);  
}


fn main() {
    let a = (1,2, 'a');
    foo(a);
    
}
```

输出

```bash
1
2
a
```

###### 例子2 形参结构体



```rust
#[derive(Debug)]
struct User {
    name: String,
    age: u32,
    student: bool
}

fn foo(User {
    name,
    age,
    student
}: User) {
    println!("{}", name);
    println!("{}", age);
    println!("{}", student);  
}


fn main() {
    let a = User {
        name: String::from("mike"),
        age: 20,
        student: false,
    };
    foo(a);
    
}

```



输出

```bash
mike
20
false
```

### Vec与HashMap的一些经验

##### 切片

```bash
&String -> &str
&Vec<u8> -> &[u8]
&Vec<T> -> &[T]
```

```rust
fn foo1(s: &str) {
}

fn foo2(s: &[u32]) {
}

fn main() {
    let s = String::from("aaa");
    foo1(&s);
    let v: Vec<u32> = vec![1,2,3,4,5];
    foo2(&v);
}
```

##### 元素所有权

​	所有权不能move出来，只能使用引用去访问

```rust
fn main() {
    let s1 = String::from("a superman");
    let s2 = String::from("two superman");
    let s3 = String::from("3 superman");
    let s4 = String::from("four superman");
    
    let v = vec![s1, s2, s3, s4];
    // println!("{:?}", s1);
    
    println!("{:?}", v);
    
    //let a = v[0];  // 不能move出来 ,会报错
    let a = &v[0];
    println!("{}", a);
}
```

##### HashMap增删改查

```rust
use std::collections::HashMap;

fn main() {

    let mut book_reviews = HashMap::new();

    // Review some books.
    book_reviews.insert(
        "Adventures of Huckleberry Finn".to_string(),
        "My favorite book.".to_string(),
    );

    book_reviews.insert(
        "Grimms' Fairy Tales".to_string(),
        "Masterpiece.".to_string(),
    );
    book_reviews.insert(
        "Pride and Prejudice".to_string(),
        "Very enjoyable.".to_string(),
    );
    book_reviews.insert(
        "The Adventures of Sherlock Holmes".to_string(),
        "Eye lyked it alot.".to_string(),
    );

    println!("");
    println!("*********************** Do  map print *********************");
    for (book, review) in &book_reviews {
        println!("{book}: \"{review}\"");
    }
    
    println!("");
    println!("");
    println!("*********************** Test contain*********************");
    println!(
        " Check for a specific one.When collections store owned values (String), they can still be queried using references (&str)."
    );
    println!("********************************************************");
    if !book_reviews.contains_key("Les Misérables") {
        println!(
            "We've got {} reviews, but Les Misérables ain't one.",
            book_reviews.len()
        );
    }
    
    
    println!("");
    println!("");
    // oops, this review has a lot of spelling mistakes, let's delete it.
    book_reviews.remove("The Adventures of Sherlock Holmes");
    println!("We've got {} reviews,after remove.", book_reviews.len());
    
    
    println!("");
    println!("");
    println!("*********************** Look up the values associated with some keys.*********************");
    // Look up the values associated with some keys.
    let to_find = ["Pride and Prejudice", "Alice's Adventure in Wonderland"];
    for &book in &to_find {
        match book_reviews.get(book) {
            Some(review) => println!("{book}: {review}"),
            None => println!("{book} is unreviewed."),
        }
    }
    
    println!("");
    println!("");
    println!("*********************** Look up the value for a key.*********************");
    // Look up the value for a key (will panic if the key is not found).
    println!("Review for Jane: {}", book_reviews["Pride and Prejudice"]);
}

```

输出

```bash
*********************** Do  map print *********************
Pride and Prejudice: "Very enjoyable."
Adventures of Huckleberry Finn: "My favorite book."
The Adventures of Sherlock Holmes: "Eye lyked it alot."
Grimms' Fairy Tales: "Masterpiece."


*********************** Test contain*********************
 Check for a specific one.When collections store owned values (String), they can still be queried using references (&str).
********************************************************
We've got 4 reviews, but Les Misérables ain't one.


We've got 3 reviews,after remove.


*********************** Look up the values associated with some keys.*********************
Pride and Prejudice: Very enjoyable.
Alice's Adventure in Wonderland is unreviewed.


*********************** Look up the value for a key.*********************
Review for Jane: Very enjoyable.
```

##### HashMap匿名创建和 `and_modify` 方法

在 Rust 中，`and_modify` 是 `HashMap` 中的一个方法，用于在插入之前对特定键的值进行修改。该方法允许你使用原地变异（in-place mutation）来修改哈希映射中指定键的值。

`and_modify` 方法接受一个闭包作为参数，闭包中的参数是键对应的可变引用。通过在闭包中修改这个可变引用，你可以对键的值进行更改。修改是在插入操作之前进行的，因此你可以在插入之前对值进行任何需要的修改操作。

```rust
use std::collections::HashMap;

fn main() {
    let mut player_stats = HashMap::new();

    fn random_stat_buff() -> u8 {
        // could actually return some random value here - let's just return
        // some fixed value for now
        42
    }

    // insert a key only if it doesn't already exist
    player_stats.entry("health").or_insert(100);
    
        // insert a key using a function that provides a new value only if it
    // doesn't already exist
    player_stats
        .entry("defence")
        .or_insert_with(random_stat_buff);
    
    player_stats.entry("mana").or_insert(200);



    // update a key, guarding against the key possibly not being set
    let stat = player_stats.entry("attack").or_insert(100);
    *stat += random_stat_buff();
    
    
    // modify an entry before an insert with in-place mutation
  //  player_stats.entry("mana").and_modify(|mana| *mana += 200);
    
    println!("mana 1 : {}", player_stats["mana"]);
    
   // player_stats.entry("mana").and_modify(|mana| *mana += 200).or_insert(100);
    
   // println!("mana 2 : {}", player_stats["mana"]);
    
    for (attrName, attrValue) in &player_stats {
        println!("{attrName}: \"{attrValue}\"");
    }
    
    println!("{:?}",player_stats);

    
    
    // for (attrName, attrValue) in &player_stats {
    //     println!("{attrName}: \"{attrValue}\"");
    // }
}

```



输出

```bash
{"mana": 100, "health": 100, "defence": 42, "attack": 142}
```

##### get返回断言测试

```rust
 use std::collections::HashMap;

// let mut map = HashMap::new();
// map.insert(1, "a");
// assert_eq!(map.get(&1), Some(&"a"));
// assert_eq!(map.get(&2), None);
fn main() {
    // let a = (1,2,'a');
    
    // let (b,c,d) = a;
    
    // println!("{:?}", a);
    // println!("{}", b);
    // println!("{}", c);
    // println!("{}", d);
    let mut map = HashMap::new();
    map.insert(1, "a");
    println!("{:?}", map.get(&1));
    println!("{:?}", map.get(&2));
    println!("{:?}", assert_eq!(map.get(&1), Some(&"a")));
    println!("{:?}", assert_eq!(map.get(&2), None));
}
```

输出

```bash
Some("a")
None
()
()
```

##### 更新值

```rust
use std::collections::HashMap;
fn main() {
    let mut map = HashMap::new();
    map.insert(1, "a");
    if let Some(x) = map.get_mut(&1) {
        *x = "b";
    }
    assert_eq!(map[&1], "b");
    println!("{:?}", map);
}
```

输出

```bash
{1: "b"}
```

##### 通过元组数组构建HashMap

```rust
use std::collections::HashMap;
fn main() {
    let map = HashMap::from([("a", 1), ("b", 2), ("c", 3)]);

    for (key, val) in map.iter() {
        println!("key: {key} val: {val}");
    }
}

```

输出

```bash
key: a val: 1
key: c val: 3
key: b val: 2
```

##### 通过Iter解引用更新值

```rust
use std::collections::HashMap;
fn main() {
    use std::collections::HashMap;

    let mut map = HashMap::from([("a", 1), ("b", 2), ("c", 3)]);

    // Update all values
    for (_, val) in map.iter_mut() {
        *val *= 2;
    }

    for (key, val) in &map {
        println!("key: {key} val: {val}");
    }
}

```

输出

```bash
key: b val: 4
key: c val: 6
key: a val: 2
```



- [Rust在线编译器](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021)
- [Rust标准库文档](https://doc.rust-lang.org/std/index.html)
- [rust编译套件和中文手册](https://kaisery.github.io/trpl-zh-cn/ch01-01-installation.html)
- [知乎教程](https://zhuanlan.zhihu.com/p/410291415)