# 第四课 泛型、Trait



### 一、泛型

##### 1.函数参数中的泛型

###### 1) `std::cmp::PartialOrd` trait 获取所有权方式

```rust
fn largest<T: std::cmp::PartialOrd + Copy>(list: Vec<T>) -> T {
    let mut largest = list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(char_list);
    println!("The largest char is {}", result);
}
```

输出

```
The largest number is 100
The largest char is y
```

`largest` 的函数体不能适用于 `T` 的所有可能的类型。因为在函数体需要比较 `T` 类型的值，不过它只能用于我们知道如何排序的类型。为了开启比较功能，标准库中定义的 `std::cmp::PartialOrd` trait 可以实现类型的比较功能。我们限制 `T` 只对实现了 `PartialOrd` 的类型有效，因为标准库为 `i32` 和 `char` 实现了 `PartialOrd`。



###### 2) 利用引用传值

```rust
fn largest<T: std::cmp::PartialOrd>(list: &Vec<T>) -> &T {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);
    println!("Vec is {:?}", number_list);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result);
}
```

输出

```bash
The largest number is 100
Vec is [34, 50, 25, 100, 65]
The largest char is y
```

##### 2.结构体中的泛型

###### 1) 一个泛型参数

```rust
#[derive(Debug)]
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
    println!("1 is {:?}", integer);
    println!("2 is {:?}", float);
}

```

输出

```bash
1 is Point { x: 5, y: 10 }
2 is Point { x: 1.0, y: 4.0 }
```

###### 2) 多个泛型参数

```rust
#[derive(Debug)]
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };

    println!("1 is {:?}", both_integer);
    println!("2 is {:?}", both_float);
    println!("3 is {:?}", integer_and_float);
}
```

输出

```
1 is Point { x: 5, y: 10 }
2 is Point { x: 1.0, y: 4.0 }
3 is Point { x: 5, y: 4.0 }
```

##### 3.枚举中的泛型

###### 1) Option

```rust
#![allow(unused)]
fn main() {
	enum Option<T> {
    	Some(T),
    	None,
	}
}

```

###### 2) Result

```rust
#![allow(unused)]
fn main() {
	enum Result<T, E> {
    	Ok(T),
    	Err(E),
	}
}
```

##### 4.方法中的泛型

###### 1) 常规用法

必须在 `impl` 后面声明 `T`，这样就可以在 `Point<T>` 上实现的方法中使用 `T` 了。通过在 `impl` 之后声明泛型 `T`，Rust 就知道 `Point` 的尖括号中的类型是泛型而不是具体类型。我们可以为泛型参数选择一个与结构体定义中声明的泛型参数所不同的名称，不过依照惯例使用了相同的名称。`impl` 中编写的方法声明了泛型类型可以定位为任何类型的实例，不管最终替换泛型类型的是何具体类型。

```rust
struct Point<T> {
    x: T,
    y: T,
}

impl<U> Point<U> {
    fn x(&self) -> &U {
        &self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
```

输出

```bash
p.x = 5
```

###### 2) 偏特化用法

这段代码意味着 `Point<f32>` 类型会有一个方法 `distance_from_origin`，而其他 `T` 不是 `f32` 类型的 `Point<T>` 实例则没有定义此方法。这个方法计算点实例与坐标 (0.0, 0.0) 之间的距离，并使用了只能用于浮点型的数学运算符。

```rust
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
```

###### 3) 方法中的泛型参数与结构体中的可以不同

在 `main` 函数中，定义了一个有 `i32` 类型的 `x`（其值为 `5`）和 `f64` 的 `y`（其值为 `10.4`）的 `Point`。`p2` 则是一个有着字符串 slice 类型的 `x`（其值为 `"Hello"`）和 `char` 类型的 `y`（其值为`c`）的 `Point`。在 `p1` 上以 `p2` 作为参数调用 `mixup` 会返回一个 `p3`，它会有一个 `i32` 类型的 `x`，因为 `x` 来自 `p1`，并拥有一个 `char` 类型的 `y`，因为 `y` 来自 `p2`。`println!` 会打印出 `p3.x = 5, p3.y = c`。

这个例子的目的是展示一些泛型通过 `impl` 声明而另一些通过方法定义声明的情况。这里泛型参数 `X1` 和 `Y1` 声明于 `impl` 之后，因为他们与结构体定义相对应。而泛型参数 `X2` 和 `Y2` 声明于 `fn mixup` 之后，因为他们只是相对于方法本身的。

```rust
struct Point<X1, Y1> {
    x: X1,
    y: Y1,
}

impl<X1, Y1> Point<X1, Y1> {
    fn mixup<X2, Y2>(self, other: Point<X2, Y2>) -> Point<X1, Y2> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}
```

输出

```bash
p3.x = 5, p3.y = c
```

### 二、Trait

##### 1. Trait Bound

###### 1）常规用法

```rust
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}

pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
```

###### 2） 限制类型

```rust
//这适用于 item1 和 item2 允许是不同类型的情况（只要它们都实现了 Summary）。
pub fn notify(item1: &impl Summary, item2: &impl Summary) {
    
}
//泛型 T 被指定为 item1 和 item2 的参数限制，如此传递给参数 item1 和 item2 值的具体类型必须一致。
pub fn notify<T: Summary>(item1: &T, item2: &T) {
    
}
```

###### 3)  通过 + 指定多个Trait Bound

如果 `notify` 需要显示 `item` 的格式化形式，同时也要使用 `summarize` 方法，那么 `item` 就需要同时实现两个不同的 trait：`Display` 和 `Summary`。这可以通过 `+` 语法实现：

```rust
pub fn notify(item: &(impl Summary + Display)) {
}

pub fn notify<T: Summary + Display>(item: &T) {
}
```

###### 4)  通过where 简化 Trait Bound

使用过多的 trait bound 也有缺点。每个泛型有其自己的 trait bound，所以有多个泛型参数的函数在名称和参数列表之间会有很长的 trait bound 信息，这使得函数签名难以阅读。为此，Rust 有另一个在函数签名之后的 `where` 从句中指定 trait bound 的语法。所以除了这么写：

```rust
//写法1
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {
}
//用where简化
fn some_function<T, U>(t: &T, u: &U) -> i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
    unimplemented!()
}

```

###### 5)  返回实现了Trait的类型

也可以在返回值中使用 `impl Trait` 语法，来返回实现了某个 trait 的类型：

```rust
fn returns_summarizable() -> impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    }
}
```

通过使用 `impl Summary` 作为返回值类型，我们指定了 `returns_summarizable` 函数返回某个实现了 `Summary` trait 的类型，但是不确定其具体的类型。在这个例子中 `returns_summarizable` 返回了一个 `Tweet`，不过调用方并不知情。

###### 6）使用Trait Bound有条件地实现方法

```rust
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}
//只有那些为 T 类型实现了 PartialOrd trait （来允许比较） 和 Display trait （来启用打印）的 Pair<T> 才会实现 cmp_display 方法
impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
```

###### 7) blanket implementation(通用实现)

也可以对任何实现了特定 trait 的类型有条件地实现 trait。对任何满足特定 trait bound 的类型实现 trait 被称为 *blanket implementations*，他们被广泛的用于 Rust 标准库中。例如，标准库为任何实现了 `Display` trait 的类型实现了 `ToString` trait。这个 `impl` 块看起来像这样：

```rust
impl<T: Display> ToString for T {
    // --snip--
}
```

也可以对任何实现了特定 trait 的类型有条件地实现 trait。对任何满足特定 trait bound 的类型实现 trait 被称为 *blanket implementations*，他们被广泛的用于 Rust 标准库中。例如，标准库为任何实现了 `Display` trait 的类型实现了 `ToString` trait。这个 `impl` 块看起来像这样：

```rust
let s = 3.to_string();
```



##### 2.Trait

###### 1）定义

```rust
//Trait 定义
pub trait Summary {
    fn summarize(&self) -> String;
}

pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}
//Trait 实现 for NewsArticle
impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}

fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from("of course, as you probably already know, people"),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
}

```

###### 2） 关联类型

```rust
trait StreamingIterator {
    type Item;
}
#[derive(Debug)]
struct Foo<T> 
    where T: StreamingIterator<Item=String> {
    x: T
}
#[derive(Debug)]
struct A;
impl StreamingIterator for A {
    type Item = String;
}

fn main() {
    let a = Foo::<A> {
        x: A,
    };
    
    println!("{:?}",a);
    
}
```

输出

```bash
Foo { x: A }
```

###### 3） Trait对象

```rust
trait Animal {
    fn talk(&self);
}
struct Cat {}
struct Dog {}
impl Animal for Cat {
    fn talk(&self) {
        println!("meow");
    }
}
impl Animal for Dog {
    fn talk(&self) {
        println!("bark");
    }
}
fn animal_talk(a: &dyn Animal) {
    a.talk();
}

//另一个泛型实现方式
//fn animal_talk<T: Animal>(a: &T) {
    //a.talk();
//}
fn main() {
    let d = Dog {};
    let c = Cat {};
    animal_talk(&d);
    animal_talk(&c);
}
```



输出

```bash
bark
meow
```

###### 4) &dyn and Box<dyn>

```rust
trait Animal {
    fn talk(&self);
}
struct Cat {}
struct Dog {}
impl Animal for Cat {
    fn talk(&self) {
        println!("meow");
    }
}
impl Animal for Dog {
    fn talk(&self) {
        println!("bark");
    }
}
fn animal_talk(a: Box<dyn Animal>) {
    a.talk();
}

fn main() {
    let d = Dog {};
    let c = Cat {};
    animal_talk(Box::new(d));
    animal_talk(Box::new(c));

    //   let ans = vec![d, c];
}
```

###### 5) trait object作为返回值类型

```rust
struct Sheep {}
struct Cow {}

trait Animal {
    // Instance method signature
    fn noise(&self) -> &'static str;
}

// Implement the `Animal` trait for `Sheep`.
impl Animal for Sheep {
    fn noise(&self) -> &'static str {
        "baaaaah!"
    }
}

// Implement the `Animal` trait for `Cow`.
impl Animal for Cow {
    fn noise(&self) -> &'static str {
        "moooooo!"
    }
}

// Returns some struct that implements Animal, but we don't know which one at compile time.
fn random_animal(random_number: f64) -> Box<dyn Animal> {
    if random_number < 0.5 {
        Box::new(Sheep {})
    } else {
        Box::new(Cow {})
    }
}

fn main() {
    let random_number = 0.234;
    let animal = random_animal(random_number);
    println!("You've randomly chosen an animal, and it says {}", animal.noise());
}
```

输出

```bash
You've randomly chosen an animal, and it says baaaaah!
```

###### 6) Vec里放Trait Object

```rust
trait Animal {
   fn talk(&self);
}
struct Cat {}
struct Dog {}
impl Animal for Cat {
  fn talk(&self) {
    println!("meow");
  }
}
impl Animal for Dog {
  fn talk(&self) {
    println!("bark");
  }
}
fn animal_talk(a: &dyn Animal) {
  a.talk();
}

fn main() {
  let d = Dog {};
  let c = Cat {};  
  animal_talk(&d);
  animal_talk(&c);

  let ans: Vec<&dyn Animal> = vec![&d, &c];

}
```



### 其他资料

- [Rust在线编译器](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021)
- [Rust标准库文档](https://doc.rust-lang.org/std/index.html)
- [rust编译套件和中文手册](https://kaisery.github.io/trpl-zh-cn/ch01-01-installation.html)
- [知乎教程](https://zhuanlan.zhihu.com/p/410291415)
- [Performance implications of `Box` vs `enum` delegation - The Rust Programming Language Forum (rust-lang.org)](https://users.rust-lang.org/t/performance-implications-of-box-trait-vs-enum-delegation/11957)
- [Polymorphism in Rust: Enums vs Traits (mattkennedy.io)](https://www.mattkennedy.io/blog/rust_polymorphism/)
- [Enum or Trait Object - Possible Rust](https://www.possiblerust.com/guide/enum-or-trait-object)